# **배열과 슬라이스의 추가적인 기능**

## **내부 요소에 순차적으로 접근**
- 배열/슬라이스에 **for...range 루프**를 사용하면 **각 요소의 인덱스와 값**을 얻어올 수 있다.
    ~~~go
    for index, value := range{}
    ~~~
- 다음 **예제 코드**를 보면 확실히 이해가 될 것이다.
    ~~~go
    numbers := []int{3, 4, 5, 7, 8, 4, 6, 8, 32, 4}
    for index, value := range numbers {
        fmt.Println(index, value)
    }
    ~~~
    ~~~
    실행 결과

    0 3
    1 4
    2 5
    3 7
    4 8
    5 4
    6 6
    7 8
    8 32
    9 4
    ~~~

- 인덱스를 사용하지 않고 요소의 값만 사용할 때는 인덱스 값을 **빈 식별자**(_)로 받으면 된다.
    ~~~go
    numbers := []int{3, 4, 5, 7, 8, 4, 6, 8, 32, 4}
    var sum int = 0
    for _, value := range numbers {
        sum += value
    }
    fmt.Println("sum: ", sum)
    ~~~
    ~~~
    실행 결과

    sum: 81
    ~~~

- 또한 **두 번째로 반환**되는 값은 **각 요소의 사본**이므로 **내부 요소의 값**을 변경하려면 **인덱스**로 접근해야 한다.
    ~~~go
    numbers := []int{3, 4, 5, 7, 8, 4, 6, 8, 32, 4}
	sum := 0
	for i := range numbers {
		numbers[i] *= 2
		sum += numbers[i]
	}
	fmt.Println("numbers:", numbers)
	fmt.Println("sum:", sum)
    ~~~
    ~~~
    실행 결과

    numbers: [6 8 10 14 16 8 12 16 64 8]
    sum: 162
    ~~~

<br>

## **부분 슬라이스 추출**
- **[] 연산자**로 **배열**이나 **슬라이스**의 일부를 **추출**할 수 있다.

- **[]연산자**로 부분 슬라이스 추출
![slice_operate](/img/slice_operate.png)

<br>

~~~go
// [] 연산자 사용 예시 코드

s := []int{1, 2, 3, 4, 5, 6, 7}
fmt.Println(s, "=", s[:3], s[3:5], s[5:])
~~~
~~~
실행 결과

[1 2 3 4 5 6 7] = [1 2 3] [4 5] [6 7]
~~~

<br>

## **슬라이스 변경**

### **1. 슬라이스 추가**
- 슬라이스에 새로운 요소나 다른 슬라이스를 추가할 때는 **append()함수**를 사용한다.

- **append() 함수의 매개변수**
    - 첫 번째 매개변수 -> **원본 슬라이스** 전달
    - 이어서 원본 슬라이스에 **추가할 요소** 전달

- 또한 슬라이스의 **각 요소**를 **개별로 추가**할 때는 **... 연산자**를 사용한다.

    ~~~go
    ns1 := []int{1, 2, 3}
	ns2 := []int{6, 7, 8}
	ns3 := []int{8, 9, 10, 11}

	ns1 = append(ns1, 4, 5)	// ns1: [1, 2, 3, 4, 5]
	ns1 = append(ns1, ns2...)		// ns1: [1, 2, 3, 4, 5, 6, 7, 8]
	ns1 = append(ns1, ns3[1:3]...)	// ns1: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

	fmt.Println(ns1)
    ~~~
    ~~~
    실행 결과

    [1, 2, 3, 4, 5, 6, 7, 8, 9 ,10]
    ~~~

- 만약 슬라이스의 **용량이 충분하지 않다면** 용량이 늘어난 **새 슬라이스**를 내부에 **만들어 반환**한다.
    ~~~go
    func main() {
        s := make([]int, 0, 3)
        for i := 0; i < 9; i++ {
            s = append(s, i)
            fmt.Printf("len: %d, cap: %d, %v\n", len(s), cap(s), s)
        }
    }
    ~~~
    ~~~
    실행 결과

    len: 1, cap: 3, [0]
    len: 2, cap: 3, [0 1]
    len: 3, cap: 3, [0 1 2]
    len: 4, cap: 6, [0 1 2 3]
    len: 5, cap: 6, [0 1 2 3 4]
    len: 6, cap: 6, [0 1 2 3 4 5]
    len: 7, cap: 12, [0 1 2 3 4 5 6]
    len: 8, cap: 12, [0 1 2 3 4 5 6 7]
    len: 9, cap: 12, [0 1 2 3 4 5 6 7 8]
    ~~~
<br>

<!-- ### **2. 슬라이스 삽입**
-  -->